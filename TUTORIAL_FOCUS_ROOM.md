# FocusFlow開発チュートリアル - フォーカスルーム編

このチュートリアルでは、FocusFlowに複数人のユーザーが同時に集中できる「フォーカスルーム」機能を実装する手順を解説します。

## 1. コンセプト：静かなる共闘空間

フォーカスルームは、単なるチャットルームではありません。同じ目標を持つ仲間と**「静かに、共に集中する」**ための空間です。ここでの主役は会話ではなく、各々の集中状態そのものです。

*   **目的**: 互いの存在を感じながらも、集中を妨げない環境を提供する。
*   **核心技術**: **WebSocket**によるリアルタイム通信。これにより、サーバーを介して各ユーザーのブラウザ間で情報を瞬時に同期させます。

## 2. 実装へのロードマップ

このチュートリアルは、以下の4ステップで実装を進めていきます。

1.  **データベース設計**: ルームの情報を保存するための新しいテーブルを定義します。
2.  **バックエンド実装 (Flask)**: WebSocketサーバーをセットアップし、ルームの作成、入退室、リアルタイム通信のロジックを構築します。
3.  **フロントエンド実装 (HTML/JavaScript)**: ルームの一覧ページ、ルーム内のページを作成し、WebSocketと連携してUIを動的に更新します。
4.  **既存機能との連携**: フォーカスモード中のゲージ情報をルーム内にリアルタイムで反映させます。

---

## Step 1: データベース設計 (models.py)

まず、フォーカスルームの情報を永続化するための器をデータベースに用意します。

### 必要なテーブル定義

`app/models.py`に、以下の仕様で新しい`FocusRoom`モデルクラスを追加する必要があります。

*   **`FocusRoom`モデル**:
    *   `id`: 主キー
    *   `name`: ルーム名 (文字列)
    *   `description`: ルームの説明や目標 (テキスト)
    *   `is_public`: 公開ルームかどうかの真偽値
    *   `owner_id`: ルーム作成者のID (`user.id`への外部キー)

### リレーションシップの定義（詳細解説）

ユーザーとルームの間の「誰が作成したか」「誰が参加しているか」という関係性を、データベース上で表現します。これにはFlask-SQLAlchemyの`relationship`機能を使います。

#### 1. 作成者との関係（1対多）

一人のユーザーが複数のルームを作成できる、という関係です。

*   **`FocusRoom`モデル側（「多」側）**:
    *   `owner_id`カラムに`db.ForeignKey('user.id')`を追加します。これは「このカラムの値は、`user`テーブルの`id`を参照しています」という宣言です。これにより、各ルームがどのユーザーに所有されているかが記録されます。

*   **`User`モデル側（「1」側）**:
    *   `created_rooms = db.relationship('FocusRoom', backref='owner', lazy=True)`のような記述を追加します。
    *   これはSQLのテーブルに新しいカラムを作るものではなく、SQLAlchemyが裏側で賢く連携してくれるための「魔法の杖」のようなものです。
    *   `'FocusRoom'`：関連付けるモデル名を指定します。
    *   `backref='owner'`: これを設定すると、`FocusRoom`のインスタンスから`.owner`という属性で、そのルームを作成した`User`インスタンスに簡単にアクセスできるようになります。（例：`my_room.owner.username`）
    *   `lazy=True`: `a_user.created_rooms`にアクセスしたタイミングで、初めて関連するルームの情報をデータベースから読み込みます。効率的なデータ取得に役立ちます。

#### 2. 参加者との関係（多対多）

一人のユーザーが複数のルームに参加でき、一つのルームには複数のユーザーが参加できる、という複雑な関係です。これを実現するには、「中間テーブル」という第三者のテーブルが必要です。

*   **ステップ1: 中間テーブルの作成**
    *   `participants`という名前で、`db.Table`を使ってモデルクラスとは別に定義します。
    *   このテーブルは、どのユーザー(`user_id`)がどのルーム(`focus_room_id`)に参加しているか、という情報だけを記録するシンプルなテーブルです。
    *   カラムは`db.Column('user_id', db.Integer, db.ForeignKey('user.id'))`と`db.Column('focus_room_id', db.Integer, db.ForeignKey('focus_room.id'))`の2つだけを持つのが一般的です。

*   **ステップ2: `User`モデルと`FocusRoom`モデルへの`relationship`の追加**
    *   `User`モデルに、`joined_rooms = db.relationship(...)`のような関係を定義します。
    *   `FocusRoom`モデルにも、`participants = db.relationship(...)`のような関係を定義します。
    *   これらの`relationship`では、`secondary=participants`という引数を指定します。これが「この関係は`participants`という中間テーブルを使って実現してください」というSQLAlchemyへの指示になります。

**作業のヒント**:
この多対多リレーションシップの実装方法は、`app/models.py`に既に存在する`followers`テーブルと、それを利用している`User`モデルの`followed`リレーションシップの構造と全く同じです。既存のコードを参考にすることで、より理解が深まるはずです。

---

## Step 2: バックエンド実装 (Flask & Flask-SocketIO)

アプリケーションの心臓部となるリアルタイム通信のロジックを構築します。

### WebSocketライブラリの導入

FlaskでWebSocketを扱うには、`Flask-SocketIO`ライブラリが非常に強力で一般的です。

*   **インストール**: `pip install Flask-SocketIO` を実行してライブラリをプロジェクトに追加します。
*   **初期化**: `app/__init__.py`で、`SocketIO`インスタンスを作成し、Flaskアプリケーションと連携させる設定を追加します。

### 新しいルートの作成 (`routes.py`)

ルームの管理に必要なWebページ用のルートを追加します。

*   `/rooms`: 公開されているフォーカスルームの一覧を表示するページ。
*   `/create_room` (GET, POST): 新しいルームを作成するためのフォームページと、フォーム送信を処理するロジック。
*   `/room/<room_id>`: 特定のルームのメインページ。このページでWebSocket通信が開始されます。

### SocketIOイベントの設計

`routes.py`（または新しく作成する`events.py`など）に、WebSocketの通信イベントを定義します。これらは`@socketio.on('イベント名')`デコレータを使って実装します。

*   **`join`イベント**:
    *   クライアント（ブラウザ）がルームに参加したときに呼び出されます。
    *   サーバー側では、`flask_socketio.join_room()`関数を使い、そのクライアントを特定のルーム名のグループに参加させます。
    *   参加が完了したら、ルーム内の全クライアントに「〇〇さんが入室しました」という情報をブロードキャスト（一斉送信）します。
*   **`leave`イベント**:
    *   クライアントがルームから退出したときに呼び出されます。
    *   `flask_socketio.leave_room()`関数でグループから離脱させます。
    *   ルーム内の全クライアントに「〇〇さんが退室しました」という情報をブロードキャストします。
*   **`update_status`イベント**:
    *   クライアントのフォーカスゲージやステータスが変更されたときに呼び出されます。
    *   受け取った新しいステータス情報を、送信者を除くルーム内の全クライアントにブロードキャストします。これにより、他のユーザーの画面にリアルタイムで変更が反映されます。

---

## Step 3: フロントエンド実装 (HTML & JavaScript)

ユーザーが実際に目にする画面と、その裏で動くロジックを作成します。

### 新しいHTMLテンプレートの作成

`app/templates/`ディレクトリに、以下のHTMLファイルを追加します。

*   `rooms.html`: ルーム一覧ページ。`routes.py`の`/rooms`ルートから渡されたルームのリストをループで表示します。
*   `create_room.html`: ルーム作成フォーム。
*   `room.html`: フォーカスルームのメインページ。参加者リスト、チャット（もし実装する場合）、各メンバーの匿名化されたフォーカスゲージを表示するエリアをHTMLで構築します。

### JavaScriptによるSocketIOクライアントの実装

`room.html`内に`<script>`タグを追加し、JavaScriptでWebSocketサーバーとの通信を実装します。

*   **ライブラリの読み込み**: `Flask-SocketIO`はクライアント用のJavaScriptライブラリを提供しています。これを`<script>`タグで読み込みます。
*   **接続とイベントハンドラ**:
    *   `io.connect()`を使ってサーバーに接続します。
    *   接続が確立したら、`socket.emit('join', {room: 'ルームID'})`のようにして、先ほどバックエンドで定義した`join`イベントをサーバーに送信します。
    *   `socket.on('イベント名', (data) => { ... })`の形で、サーバーから送られてくるイベントを待ち受けます。例えば、サーバーから`status_updated`イベントが送られてきたら、受け取ったデータ(`data`)を使って特定のユーザーのゲージ表示を更新する、といったDOM操作のコードを記述します。

---

## Step 4: 既存機能との連携

最後に、フォーカスモードとルーム機能を連携させます。

### フォーカスゲージの情報を送信する

`app/templates/focus.html`のJavaScriptを修正します。

*   **現状**: `focus.html`の`sendUserStatusUpdate`関数は、`fetch`を使ってユーザー自身のステータスをサーバーに送信しています。
*   **変更後**: この`sendUserStatusUpdate`関数に、**もしユーザーがフォーカスルームに参加している場合**は、`socket.emit('update_status', ...)`を実行して、現在のゲージレベルとステータスをルームにもブロードキャストする処理を追加します。

これにより、ユーザーが一人でフォーカスモードに入るとその情報はプロフィールに反映され、ルーム内でフォーカスモードに入ると、その集中状態がルームメンバーにもリアルタイムで共有されるようになります。

## まとめ

お疲れ様でした！このチュートリアルで概説したステップを実装することで、FocusFlowにインタラクティブな「フォーカスルーム」機能が追加され、ユーザーは孤独な作業から解放され、仲間と共に集中力を高める新たな体験を得ることができます。

ここからさらに、ホワイトボード機能やBGM機能など、`focusflow.md`にある高度な機能へと発展させていくことが可能です。
