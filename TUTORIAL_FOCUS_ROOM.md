# FocusFlow開発チュートリアル - フォーカスルーム編

このチュートリアルでは、FocusFlowに複数人のユーザーが同時に集中できる「フォーカスルーム」機能を実装する手順を解説します。

## 1. コンセプト：静かなる共闘空間

フォーカスルームは、単なるチャットルームではありません。同じ目標を持つ仲間と**「静かに、共に集中する」**ための空間です。ここでの主役は会話ではなく、各々の集中状態そのものです。

*   **目的**: 互いの存在を感じながらも、集中を妨げない環境を提供する。
*   **核心技術**: **WebSocket**によるリアルタイム通信。これにより、サーバーを介して各ユーザーのブラウザ間で情報を瞬時に同期させます。

## 2. 実装へのロードマップ

このチュートリアルは、以下の4ステップで実装を進めていきます。

1.  **データベース設計**: ルームの情報を保存するための新しいテーブルを定義します。
2.  **バックエンド実装 (Flask)**: WebSocketサーバーをセットアップし、ルームの作成、入退室、リアルタイム通信のロジックを構築します。
3.  **フロントエンド実装 (HTML/JavaScript)**: ルームの一覧ページ、ルーム内のページを作成し、WebSocketと連携してUIを動的に更新します。
4.  **既存機能との連携**: フォーカスモード中のゲージ情報をルーム内にリアルタイムで反映させます。

---

## Step 1: データベース設計 (models.py)

まず、フォーカスルームの情報を永続化するための器をデータベースに用意します。

### 必要なテーブル定義

`app/models.py`に、以下の仕様で新しい`FocusRoom`モデルクラスを追加する必要があります。

*   **`FocusRoom`モデル**:
    *   `id`: 主キー
    *   `name`: ルーム名 (文字列)
    *   `description`: ルームの説明や目標 (テキスト)
    *   `is_public`: 公開ルームかどうかの真偽値
    *   `owner_id`: ルーム作成者のID (`user.id`への外部キー)

### リレーションシップの定義

ユーザーとルームの関係性を定義します。

*   **作成者との関係**: `User`モデルと`FocusRoom`モデルを1対多の関係で結びつけます。これにより、あるユーザーが作成したルームを簡単に取得できるようになります。
*   **参加者との関係**: ユーザーがどのルームに参加しているかを管理するために、`User`モデルと`FocusRoom`モデルの間に**多対多**のリレーションシップを定義します。これには、`participants`という名前の中間テーブルを作成するのが一般的です。

**作業のヒント**:
`TUTORIAL_SNS.md`で実装した`followers`テーブルの定義が、多対多リレーションシップを実装する上で大変参考になります。

---

## Step 2: バックエンド実装 (Flask & Flask-SocketIO)

アプリケーションの心臓部となるリアルタイム通信のロジックを構築します。

### WebSocketライブラリの導入

FlaskでWebSocketを扱うには、`Flask-SocketIO`ライブラリが非常に強力で一般的です。

*   **インストール**: `pip install Flask-SocketIO` を実行してライブラリをプロジェクトに追加します。
*   **初期化**: `app/__init__.py`で、`SocketIO`インスタンスを作成し、Flaskアプリケーションと連携させる設定を追加します。

### 新しいルートの作成 (`routes.py`)

ルームの管理に必要なWebページ用のルートを追加します。

*   `/rooms`: 公開されているフォーカスルームの一覧を表示するページ。
*   `/create_room` (GET, POST): 新しいルームを作成するためのフォームページと、フォーム送信を処理するロジック。
*   `/room/<room_id>`: 特定のルームのメインページ。このページでWebSocket通信が開始されます。

### SocketIOイベントの設計

`routes.py`（または新しく作成する`events.py`など）に、WebSocketの通信イベントを定義します。これらは`@socketio.on('イベント名')`デコレータを使って実装します。

*   **`join`イベント**:
    *   クライアント（ブラウザ）がルームに参加したときに呼び出されます。
    *   サーバー側では、`flask_socketio.join_room()`関数を使い、そのクライアントを特定のルーム名のグループに参加させます。
    *   参加が完了したら、ルーム内の全クライアントに「〇〇さんが入室しました」という情報をブロードキャスト（一斉送信）します。
*   **`leave`イベント**:
    *   クライアントがルームから退出したときに呼び出されます。
    *   `flask_socketio.leave_room()`関数でグループから離脱させます。
    *   ルーム内の全クライアントに「〇〇さんが退室しました」という情報をブロードキャストします。
*   **`update_status`イベント**:
    *   クライアントのフォーカスゲージやステータスが変更されたときに呼び出されます。
    *   受け取った新しいステータス情報を、送信者を除くルーム内の全クライアントにブロードキャストします。これにより、他のユーザーの画面にリアルタイムで変更が反映されます。

---

## Step 3: フロントエンド実装 (HTML & JavaScript)

ユーザーが実際に目にする画面と、その裏で動くロジックを作成します。

### 新しいHTMLテンプレートの作成

`app/templates/`ディレクトリに、以下のHTMLファイルを追加します。

*   `rooms.html`: ルーム一覧ページ。`routes.py`の`/rooms`ルートから渡されたルームのリストをループで表示します。
*   `create_room.html`: ルーム作成フォーム。
*   `room.html`: フォーカスルームのメインページ。参加者リスト、チャット（もし実装する場合）、各メンバーの匿名化されたフォーカスゲージを表示するエリアをHTMLで構築します。

### JavaScriptによるSocketIOクライアントの実装

`room.html`内に`<script>`タグを追加し、JavaScriptでWebSocketサーバーとの通信を実装します。

*   **ライブラリの読み込み**: `Flask-SocketIO`はクライアント用のJavaScriptライブラリを提供しています。これを`<script>`タグで読み込みます。
*   **接続とイベントハンドラ**:
    *   `io.connect()`を使ってサーバーに接続します。
    *   接続が確立したら、`socket.emit('join', {room: 'ルームID'})`のようにして、先ほどバックエンドで定義した`join`イベントをサーバーに送信します。
    *   `socket.on('イベント名', (data) => { ... })`の形で、サーバーから送られてくるイベントを待ち受けます。例えば、サーバーから`status_updated`イベントが送られてきたら、受け取ったデータ(`data`)を使って特定のユーザーのゲージ表示を更新する、といったDOM操作のコードを記述します。

---

## Step 4: 既存機能との連携

最後に、フォーカスモードとルーム機能を連携させます。

### フォーカスゲージの情報を送信する

`app/templates/focus.html`のJavaScriptを修正します。

*   **現状**: `focus.html`の`sendUserStatusUpdate`関数は、`fetch`を使ってユーザー自身のステータスをサーバーに送信しています。
*   **変更後**: この`sendUserStatusUpdate`関数に、**もしユーザーがフォーカスルームに参加している場合**は、`socket.emit('update_status', ...)`を実行して、現在のゲージレベルとステータスをルームにもブロードキャストする処理を追加します。

これにより、ユーザーが一人でフォーカスモードに入るとその情報はプロフィールに反映され、ルーム内でフォーカスモードに入ると、その集中状態がルームメンバーにもリアルタイムで共有されるようになります。

## まとめ

お疲れ様でした！このチュートリアルで概説したステップを実装することで、FocusFlowにインタラクティブな「フォーカスルーム」機能が追加され、ユーザーは孤独な作業から解放され、仲間と共に集中力を高める新たな体験を得ることができます。

ここからさらに、ホワイトボード機能やBGM機能など、`focusflow.md`にある高度な機能へと発展させていくことが可能です。
