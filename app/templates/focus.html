<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>フォーカスモード - FocusFlow</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <style>
        html, body { overflow: hidden; }
        .focus-container { display: flex; flex-direction: column; justify-content: center; align-items: center; width: 100vw; height: 100vh; background-color: var(--background-color); color: var(--text-color); text-align: center; transition: background-color 0.5s; }
        .focus-container.focus-bg { background-color: #1c1c1e; }
        .focus-container.break-bg { background-color: #0d2a1a; }
        #task-name { font-size: 2rem; font-weight: 600; color: var(--text-secondary-color); margin-bottom: 1rem; }
        #current-mode { font-size: 2.5rem; font-weight: 700; margin-bottom: 1rem; transition: color 0.5s; }
        #current-mode.focus { color: #34aadc; }
        #current-mode.break { color: #34dc7e; }
        #timer-display { font-size: 12rem; font-weight: 700; font-family: 'Courier New', Courier, monospace; line-height: 1; }
        #gauge-container { width: 80%; max-width: 600px; height: 20px; background-color: #3a3a3c; border-radius: 10px; margin-top: 1.5rem; overflow: hidden; position: relative; }
        #gauge-bar { width: 100%; height: 100%; background-color: var(--primary-color); border-radius: 10px; transition: width 0.3s ease-in-out, background-color 0.5s; display: flex; justify-content: center; align-items: center; }
        #gauge-percent { color: white; font-size: 0.8rem; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); position: absolute; width: 100%; text-align: center; }
        #accumulated-time { margin-top: 1.5rem; font-size: 1.5rem; color: var(--text-secondary-color); }
        .end-button-container { margin-top: 3rem; }

        @media (max-width: 768px) {
            #task-name { font-size: 1.5rem; }
            #current-mode { font-size: 2rem; }
            #timer-display { font-size: 8rem; }
            #accumulated-time { font-size: 1.2rem; }
            #gauge-container { width: 90%; }
        }
        @media (max-width: 480px) {
            #task-name { font-size: 1.2rem; }
            #current-mode { font-size: 1.8rem; }
            #timer-display { font-size: 6rem; }
            #accumulated-time { font-size: 1rem; }
            #gauge-container { width: 95%; }
        }
    </style>
</head>
<body>
    <div id="focus-container" class="focus-container">
        <h1 id="task-name">{{ task_name }}</h1>
        <p id="current-mode">フォーカスモード</p>
        <div id="timer-display">25:00</div>
        <div id="gauge-container"><div id="gauge-bar"><span id="gauge-percent"></span></div></div>
        <div id="accumulated-time">合計フォーカス時間: 0分</div>
        <div class="end-button-container">
            <button id="end-session-btn" class="btn btn-secondary">終了して記録する</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const FOCUS_TIME_SECONDS = 25 * 60;
            const BREAK_TIME_SECONDS = 5 * 60;
            const GAUGE_RECOVERY_RATE = 0.2;
            const GAUGE_PENALTY_RATE = 1.5;
            const taskName = "{{ task_name|escape }}";

            const elements = { container: document.getElementById('focus-container'), timerDisplay: document.getElementById('timer-display'), currentModeDisplay: document.getElementById('current-mode'), accumulatedTimeDisplay: document.getElementById('accumulated-time'), endSessionBtn: document.getElementById('end-session-btn'), gaugeBar: document.getElementById('gauge-bar'), gaugePercent: document.getElementById('gauge-percent') };
            const sound = { notification: new Audio('https://soundeffect-lab.info/sound/button/mp3/decision1.mp3') };

            let state = {
                timerId: null, mode: 'FOCUS', targetTime: 0,
                totalAccumulatedFocusTime: 0, currentPhaseStartTime: 0,
                gaugeLevel: 10, lastHiddenTime: 0, gaugeLevelOnHide: 100,
                wakeLock: null,
                isSessionActive: false
            };

            const toggleWakeLock = async (enable) => {
                if (enable) {
                    try {
                        if ('wakeLock' in navigator) {
                            state.wakeLock = await navigator.wakeLock.request('screen');
                            console.log('Wake Lock is active.');
                        }
                    } catch (err) {
                        console.error(`${err.name}, ${err.message}`);
                    }
                } else {
                    if (state.wakeLock !== null) {
                        await state.wakeLock.release();
                        state.wakeLock = null;
                        console.log('Wake Lock was released.');
                    }
                }
            };

            async function endSession() {
                clearInterval(state.timerId);
                
                let finalFocusTime = state.totalAccumulatedFocusTime;
                if (state.mode === 'FOCUS') { finalFocusTime += (Date.now() - state.currentPhaseStartTime); }
                const totalMinutes = Math.floor(finalFocusTime / 1000 / 60);

                const confirmEnd = confirm(`${totalMinutes}分のフォーカスを記録して終了しますか？`);

                if (confirmEnd) {
                    state.isSessionActive = false;
                    await toggleWakeLock(false);
                    logSession(totalMinutes);
                } else {
                    state.timerId = setInterval(tick, 1000);
                    await toggleWakeLock(true);
                }
            }

            function logSession(duration) {
                fetch("{{ url_for('main.log_session') }}", {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ task_name: taskName, duration_minutes: duration })
                })
                .then(res => res.json())
                .then(data => {
                    if (data.status === 'success') { window.location.href = "{{ url_for('main.dashboard') }}"; }
                    else { alert('エラー: ' + data.message); }
                })
                .catch(err => { console.error('Error:', err); alert('サーバーとの通信中にエラーが発生しました。'); });
            }

            function handleVisibilityChange() {
                if (document.hidden) {
                    state.lastHiddenTime = Date.now();
                    state.gaugeLevelOnHide = state.gaugeLevel;
                } else {
                    const hiddenDuration = Date.now() - state.lastHiddenTime;
                    const penalty = (hiddenDuration / 1000) * GAUGE_PENALTY_RATE;
                    state.gaugeLevel = Math.max(0, state.gaugeLevelOnHide - penalty);
                }
            }

            function updateDisplay() {
                const now = Date.now();
                const timeLeft = Math.round((state.targetTime - now) / 1000);
                if (timeLeft >= 0) {
                    elements.timerDisplay.textContent = `${String(Math.floor(timeLeft / 60)).padStart(2, '0')}:${String(timeLeft % 60).padStart(2, '0')}`;
                }
                let currentFocusTime = state.totalAccumulatedFocusTime;
                if (state.mode === 'FOCUS') { currentFocusTime += (now - state.currentPhaseStartTime); }
                elements.accumulatedTimeDisplay.textContent = `合計フォーカス時間: ${Math.floor(currentFocusTime / 1000 / 60)}分`;
                elements.gaugeBar.style.width = `${state.gaugeLevel}%`;
                elements.gaugePercent.textContent = `${Math.round(state.gaugeLevel)}%`;
            }

            function startPhase(mode) {
                if (state.mode === 'FOCUS') { state.totalAccumulatedFocusTime += (state.targetTime - state.currentPhaseStartTime); }
                state.mode = mode;
                state.currentPhaseStartTime = Date.now();
                const duration = (mode === 'FOCUS') ? FOCUS_TIME_SECONDS : BREAK_TIME_SECONDS;
                state.targetTime = state.currentPhaseStartTime + duration * 1000;
                elements.currentModeDisplay.textContent = (mode === 'FOCUS') ? 'フォーカスモード' : '休憩モード';
                elements.currentModeDisplay.className = (mode === 'FOCUS') ? 'focus' : 'break';
                elements.container.className = 'focus-container ' + ((mode === 'FOCUS') ? 'focus-bg' : 'break-bg');
                sound.notification.play().catch(e => console.log("サウンドの再生に失敗"));
            }

            function tick() {
                if (Date.now() >= state.targetTime) { startPhase(state.mode === 'FOCUS' ? 'BREAK' : 'FOCUS'); }
                if (!document.hidden && state.mode === 'FOCUS') { state.gaugeLevel = Math.min(100, state.gaugeLevel + GAUGE_RECOVERY_RATE); }
                updateDisplay();
            }

            async function init() {
                state.isSessionActive = true;
                await toggleWakeLock(true);
                state.currentPhaseStartTime = Date.now();
                state.targetTime = state.currentPhaseStartTime + FOCUS_TIME_SECONDS * 1000;
                elements.container.classList.add('focus-bg');
                elements.currentModeDisplay.classList.add('focus');
                document.addEventListener('visibilitychange', handleVisibilityChange);
                state.timerId = setInterval(tick, 1000);
                tick();
                elements.endSessionBtn.addEventListener('click', endSession);
            }

            init();
        });

        window.addEventListener('beforeunload', (event) => {
            if (state.isSessionActive) {
                event.preventDefault();
                event.returnValue = 'フォーカスセッションが進行中です。ページを離れると記録されません。';
            }
        });
    </script>
</body>
</html>