<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>フォーカスモード - FocusFlow</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <style>
        html, body { overflow: hidden; }
        .focus-container { display: flex; flex-direction: column; justify-content: center; align-items: center; width: 100vw; height: 100vh; background-color: var(--background-color); color: var(--text-color); text-align: center; transition: background-color 0.5s; box-sizing: border-box; }
        .focus-container.focus-bg { background-color: #1c1c1e; }
        .focus-container.break-bg { background-color: #0d2a1a; }
        .focus-container.flow-state-bg { border: 5px solid #ff00ff; box-shadow: 0 0 20px #ff00ff; }
        #task-name { font-size: 2rem; font-weight: 600; color: var(--text-secondary-color); margin-bottom: 1rem; }
        #current-mode { font-size: 2.5rem; font-weight: 700; margin-bottom: 1rem; transition: color 0.5s; }
        #current-mode.focus { color: #34aadc; }
        #current-mode.break { color: #34dc7e; }
        #timer-display { font-size: 12rem; font-weight: 700; font-family: 'Courier New', Courier, monospace; line-height: 1; }
        #gauge-container { width: 80%; max-width: 600px; height: 20px; background-color: #3a3a3c; border-radius: 10px; margin-top: 1.5rem; overflow: hidden; position: relative; }
        #gauge-bar { width: 100%; height: 100%; background-color: var(--primary-color); border-radius: 10px; transition: width 0.3s ease-in-out, background-color 0.5s; display: flex; justify-content: center; align-items: center; }
        #gauge-percent { color: white; font-size: 0.8rem; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); position: absolute; width: 100%; text-align: center; }
        #accumulated-time { margin-top: 1.5rem; font-size: 1.5rem; color: var(--text-secondary-color); }
        .end-button-container { margin-top: 3rem; }

        @media (max-width: 768px) {
            #task-name { font-size: 1.5rem; }
            #current-mode { font-size: 2rem; }
            #timer-display { font-size: 8rem; }
            #accumulated-time { font-size: 1.2rem; }
            #gauge-container { width: 90%; }
        }
        @media (max-width: 480px) {
            #task-name { font-size: 1.2rem; }
            #current-mode { font-size: 1.8rem; }
            #timer-display { font-size: 6rem; }
            #accumulated-time { font-size: 1rem; }
            #gauge-container { width: 95%; }
        }
        /* 横画面（ランドスケープ）または高さが小さい場合の調整 */
        @media (orientation: landscape) and (max-height: 450px), (max-height: 450px) {
            #task-name { font-size: 1rem; margin-bottom: 0.5rem; }
            #current-mode { font-size: 1.5rem; margin-bottom: 0.5rem; }
            #timer-display { font-size: 5rem; }
            #gauge-container { margin-top: 0.5rem; }
            #accumulated-time { font-size: 1rem; margin-top: 0.5rem; }
            .end-button-container { margin-top: 1rem; }
        }
    </style>
</head>
<body>
    <div id="focus-container" class="focus-container">
        <h1 id="task-name">{{ task_name }}</h1>
        <p id="current-mode">フォーカスモード</p>
        <div id="timer-display">25:00</div>
        <div id="gauge-container"><div id="gauge-bar"><span id="gauge-percent"></span></div></div>
        <div id="accumulated-time">合計フォーカス時間: 0分</div>
        <div class="end-button-container">
            <button id="end-session-btn" class="btn btn-secondary">終了して記録する</button>
        </div>
    </div>

    <div id="debug-controls" style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; z-index: 9999;">
        <h4 style="color: white; margin-top: 0; margin-bottom: 5px;">Debug</h4>
        <button id="debug-gauge-0" class="btn btn-sm" style="margin-bottom: 5px;">Set Gauge 0</button>
        <button id="debug-gauge-50" class="btn btn-sm" style="margin-bottom: 5px;">Set Gauge 50</button>
        <button id="debug-gauge-100" class="btn btn-sm">Set Gauge 100</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const FOCUS_TIME_SECONDS = 25 * 60;
            const BREAK_TIME_SECONDS = 5 * 60;
            const GAUGE_RECOVERY_RATE = 0.2;
            const GAUGE_PENALTY_RATE = 1.5;
            const FLOW_STATE_THRESHOLD = 80; // 80%
            const FLOW_STATE_DURATION = 5 * 60 * 1000; // 5 minutes
            <body>
    <div id="focus-container" class="focus-container">
        <h1 id="task-name">{{ task_name }}</h1>
        <p id="current-mode">フォーカスモード</p>
        <div id="timer-display">25:00</div>
        <div id="gauge-container"><div id="gauge-bar"><span id="gauge-percent"></span></div></div>
        <div id="accumulated-time">合計フォーカス時間: 0分</div>
        <div class="end-button-container">
            <button id="end-session-btn" class="btn btn-secondary">終了して記録する</button>
        </div>
    </div>

    <div id="debug-controls" style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; z-index: 9999;">
        <h4 style="color: white; margin-top: 0; margin-bottom: 5px;">Debug</h4>
        <button id="debug-gauge-0" class="btn btn-sm" style="margin-bottom: 5px;">Set Gauge 0</button>
        <button id="debug-gauge-50" class="btn btn-sm" style="margin-bottom: 5px;">Set Gauge 50</button>
        <button id="debug-gauge-100" class="btn btn-sm">Set Gauge 100</button>
    </div>

    <!-- On-screen debug console -->
    <div id="debug-console" style="position: absolute; bottom: 0; left: 0; width: 100%; height: 150px; background: rgba(0,0,0,0.7); color: white; font-family: monospace; overflow-y: scroll; z-index: 10000; padding: 10px; box-sizing: border-box; display: block;">
        <h4 style="margin: 0 0 5px 0; color: yellow; font-weight: bold;">Debug Console</h4>
        <div id="console-output"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Remote Console for WebView Debugging ---
            const consoleOutput = document.getElementById('console-output');
            if (consoleOutput) {
                const originalConsoleLog = console.log;
                const originalConsoleError = console.error;
                const originalConsoleWarn = console.warn;

                function logToScreen(message, type = 'log') {
                    const p = document.createElement('p');
                    p.style.margin = '2px 0';
                    p.style.borderBottom = '1px solid #555';
                    p.style.paddingBottom = '2px';

                    let displayMessage;
                    try {
                        displayMessage = (typeof message === 'object') ? JSON.stringify(message) : String(message);
                    } catch (e) {
                        displayMessage = 'Could not stringify object.';
                    }
                    p.textContent = `[${type.toUpperCase()}] ${displayMessage}`;
                    if (type === 'error') p.style.color = '#ff8080'; // Light red
                    if (type === 'warn') p.style.color = '#ffff80'; // Light yellow
                    consoleOutput.appendChild(p);
                    // Auto-scroll to the bottom
                    consoleOutput.scrollTop = consoleOutput.scrollHeight;
                }

                console.log = function() {
                    originalConsoleLog.apply(console, arguments);
                    logToScreen(Array.from(arguments).join(' '), 'log');
                };
                console.error = function() {
                    originalConsoleError.apply(console, arguments);
                    logToScreen(Array.from(arguments).join(' '), 'error');
                };
                console.warn = function() {
                    originalConsoleWarn.apply(console, arguments);
                    logToScreen(Array.from(arguments).join(' '), 'warn');
                };

                window.onerror = function(message, source, lineno, colno, error) {
                    logToScreen(`UNCAUGHT ERROR: ${message}`, 'error');
                    if (source) {
                        logToScreen(`at ${source}:${lineno}:${colno}`, 'error');
                    }
                    if (error && error.stack) {
                        logToScreen(error.stack, 'error');
                    }
                    return true; // Prevents the default browser error handling
                };
                console.log('Debug console initialized.');
            }
            // --- End Remote Console ---


            const FOCUS_TIME_SECONDS = 25 * 60;
            const BREAK_TIME_SECONDS = 5 * 60;
            const GAUGE_RECOVERY_RATE = 0.2;
            const GAUGE_PENALTY_RATE = 1.5;
            const FLOW_STATE_THRESHOLD = 80; // 80%
            const FLOW_STATE_DURATION = 5 * 60 * 1000; // 5 minutes
            const taskName = '''{{ task_name|escape }}''';

            const elements = { container: document.getElementById('focus-container'), timerDisplay: document.getElementById('timer-display'), currentModeDisplay: document.getElementById('current-mode'), accumulatedTimeDisplay: document.getElementById('accumulated-time'), endSessionBtn: document.getElementById('end-session-btn'), gaugeBar: document.getElementById('gauge-bar'), gaugePercent: document.getElementById('gauge-percent') };
            const sound = { notification: new Audio('''{{ url_for('static', filename='sounds/decision1.mp3') }}''') };

            let state = {
                timerId: null, mode: 'FOCUS', targetTime: 0,
                totalAccumulatedFocusTime: 0, currentPhaseStartTime: 0,
                gaugeLevel: 10, lastHiddenTime: 0, gaugeLevelOnHide: 100,
                wakeLock: null,
                isSessionActive: false,
                statusUpdateIntervalId: null,
                isFlowState: false,
                flowStateStartTime: null
            };

            async function sendUserStatusUpdate(status, gaugeLevel) {
                console.log('sendUserStatusUpdate: Sending status', status, 'gauge', gaugeLevel);
                try {
                    const response = await fetch('''{{ url_for('main.update_user_status') }}''', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ status: status, gauge_level: gaugeLevel })
                    });
                    const data = await response.json();
                    console.log('sendUserStatusUpdate: Server response', data);
                    if (data.status !== 'success') {
                        console.error('Failed to update user status:', data.message);
                    }
                } catch (error) {
                    console.error('Error sending user status update:', error);
                }
            }

            const toggleWakeLock = async (enable) => {
                console.log('toggleWakeLock called with:', enable);
                if (enable) {
                    try {
                        if ('wakeLock' in navigator) {
                            state.wakeLock = await navigator.wakeLock.request('screen');
                            console.log('Wake Lock is active.');
                        } else {
                            console.warn('Wake Lock API not available.');
                        }
                    } catch (err) {
                        console.error(`Wake Lock request failed: ${err.name}, ${err.message}`);
                    }
                } else {
                    if (state.wakeLock !== null) {
                        try {
                            await state.wakeLock.release();
                            state.wakeLock = null;
                            console.log('Wake Lock was released.');
                        } catch(err) {
                            console.error(`Wake Lock release failed: ${err.name}, ${err.message}`);
                        }
                    }
                }
            };

            async function endSession() {
                try {
                    console.log('endSession function started.');
                    clearInterval(state.timerId);
                    clearInterval(state.statusUpdateIntervalId);
                    await toggleWakeLock(false);
                    
                    let finalFocusTime = state.totalAccumulatedFocusTime;
                    if (state.mode === 'FOCUS') { finalFocusTime += (Date.now() - state.currentPhaseStartTime); }
                    const totalMinutes = Math.floor(finalFocusTime / 1000 / 60);
                    console.log(`Calculated focus time: ${totalMinutes} minutes.`);

                    showCustomConfirm(`${totalMinutes}分のフォーカスを記録して終了しますか？`, async (confirmed) => {
                        console.log(`Confirmation callback. User confirmed: ${confirmed}`);
                        if (confirmed) {
                            state.isSessionActive = false;
                            await sendUserStatusUpdate('オフライン', 0);
                            logSession(totalMinutes);
                        } else {
                            console.log('User cancelled. Restarting timers.');
                            state.timerId = setInterval(tick, 1000);
                            state.statusUpdateIntervalId = setInterval(() => {
                                sendUserStatusUpdate(state.mode === 'FOCUS' ? 'フォーカス中' : '休憩中', Math.round(state.gaugeLevel));
                            }, 5000);
                            await toggleWakeLock(true);
                        }
                    });
                } catch (e) {
                    console.error('CRITICAL ERROR in endSession:', e);
                }
            }

            function logSession(duration) {
                console.log(`Logging session of ${duration} minutes.`);
                fetch('''{{ url_for('main.log_session') }}''', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ task_name: taskName, duration_minutes: duration })
                })
                .then(res => {
                    console.log('logSession fetch response received.');
                    return res.json();
                })
                .then(data => {
                    console.log('logSession data processed:', data);
                    if (data.status === 'success') { 
                        window.location.href = '''{{ url_for('main.dashboard') }}'''; 
                    } else { 
                        showCustomAlert('エラー: ' + data.message); 
                    }
                })
                .catch(err => { 
                    console.error('Error in logSession fetch:', err); 
                    showCustomAlert('サーバーとの通信中にエラーが発生しました。'); 
                });
            }

            function handleVisibilityChange() {
                console.log(`Visibility changed. document.hidden is: ${document.hidden}`);
                if (document.hidden) {
                    state.lastHiddenTime = Date.now();
                    state.gaugeLevelOnHide = state.gaugeLevel;
                } else {
                    const hiddenDuration = Date.now() - state.lastHiddenTime;
                    const penalty = (hiddenDuration / 1000) * GAUGE_PENALTY_RATE;
                    console.log(`Page was hidden for ${hiddenDuration}ms. Penalty is ${penalty}.`);
                    state.gaugeLevel = Math.max(0, state.gaugeLevelOnHide - penalty);
                }
            }

            function updateDisplay() {
                const now = Date.now();
                const timeLeft = Math.round((state.targetTime - now) / 1000);
                if (timeLeft >= 0) {
                    elements.timerDisplay.textContent = `${String(Math.floor(timeLeft / 60)).padStart(2, '0')}:${String(timeLeft % 60).padStart(2, '0')}`;
                }
                let currentFocusTime = state.totalAccumulatedFocusTime;
                if (state.mode === 'FOCUS') { currentFocusTime += (now - state.currentPhaseStartTime); }
                elements.accumulatedTimeDisplay.textContent = `合計フォーカス時間: ${Math.floor(currentFocusTime / 1000 / 60)}分`;
                elements.gaugeBar.style.width = `${state.gaugeLevel}%`;
                elements.gaugePercent.textContent = `${Math.round(state.gaugeLevel)}%`;
            }

            function startPhase(mode) {
                console.log(`Starting new phase: ${mode}`);
                if (state.mode === 'FOCUS') { state.totalAccumulatedFocusTime += (state.targetTime - state.currentPhaseStartTime); }
                state.mode = mode;
                state.currentPhaseStartTime = Date.now();
                const duration = (mode === 'FOCUS') ? FOCUS_TIME_SECONDS : BREAK_TIME_SECONDS;
                state.targetTime = state.currentPhaseStartTime + duration * 1000;
                elements.currentModeDisplay.textContent = (mode === 'FOCUS') ? 'フォーカスモード' : '休憩モード';
                elements.currentModeDisplay.className = (mode === 'FOCUS') ? 'focus' : 'break';
                elements.container.className = 'focus-container ' + ((mode === 'FOCUS') ? 'focus-bg' : 'break-bg');
                sound.notification.play().catch(e => console.error("Audio playback failed:", e));
                sendUserStatusUpdate(state.mode === 'FOCUS' ? 'フォーカス中' : '休憩中', Math.round(state.gaugeLevel));
            }

            function tick() {
                if (Date.now() >= state.targetTime) { startPhase(state.mode === 'FOCUS' ? 'BREAK' : 'FOCUS'); }
                if (!document.hidden && state.mode === 'FOCUS' && state.gaugeLevel < 100) { state.gaugeLevel = Math.min(100, state.gaugeLevel + GAUGE_RECOVERY_RATE); }

                if (state.mode === 'FOCUS' && !state.isFlowState) {
                    if (state.gaugeLevel >= FLOW_STATE_THRESHOLD) {
                        if (state.flowStateStartTime === null) {
                            state.flowStateStartTime = Date.now();
                        } else if (Date.now() - state.flowStateStartTime >= FLOW_STATE_DURATION) {
                            enterFlowState();
                        }
                    } else {
                        state.flowStateStartTime = null;
                    }
                }
                updateDisplay();
            }

            function enterFlowState() {
                if (state.isFlowState) return;
                console.log('Entering Flow State!');
                state.isFlowState = true;
                elements.container.classList.add('flow-state-bg');
                elements.currentModeDisplay.textContent = 'フロー状態';
                sendUserStatusUpdate('フロー状態', Math.round(state.gaugeLevel));
                fetch('''{{ url_for('main.flow_state_achieved') }}''', { method: 'POST' });
            }

            async function init() {
                console.log('Initializing focus session.');
                state.isSessionActive = true;
                await toggleWakeLock(true);
                state.currentPhaseStartTime = Date.now();
                state.targetTime = state.currentPhaseStartTime + FOCUS_TIME_SECONDS * 1000;
                elements.container.classList.add('focus-bg');
                elements.currentModeDisplay.classList.add('focus');
                document.addEventListener('visibilitychange', handleVisibilityChange);
                state.timerId = setInterval(tick, 1000);
                
                await sendUserStatusUpdate('フォーカス中', Math.round(state.gaugeLevel));

                state.statusUpdateIntervalId = setInterval(() => {
                    if (!state.isFlowState) {
                        sendUserStatusUpdate(state.mode === 'FOCUS' ? 'フォーカス中' : '休憩中', Math.round(state.gaugeLevel));
                    }
                }, 5000);

                tick();
                elements.endSessionBtn.addEventListener('click', endSession);

                // --- Debug controls setup ---
                const debugGauge0Btn = document.getElementById('debug-gauge-0');
                const debugGauge50Btn = document.getElementById('debug-gauge-50');
                const debugGauge100Btn = document.getElementById('debug-gauge-100');
                if(debugGauge0Btn) debugGauge0Btn.addEventListener('click', () => { state.gaugeLevel = 0; updateDisplay(); });
                if(debugGauge50Btn) debugGauge50Btn.addEventListener('click', () => { state.gaugeLevel = 50; updateDisplay(); });
                if(debugGauge100Btn) debugGauge100Btn.addEventListener('click', () => { state.gaugeLevel = 100; updateDisplay(); });
                console.log('Focus session initialized.');
            }

            init().catch(err => console.error("Initialization failed:", err));
        });

        window.addEventListener('unload', () => {
            if (state.isSessionActive) {
                const data = JSON.stringify({ status: 'オフライン', gauge_level: 0 });
                navigator.sendBeacon('''{{ url_for('main.update_user_status') }}''', data);
            }
        });
    </script>
</body>

            const elements = { container: document.getElementById('focus-container'), timerDisplay: document.getElementById('timer-display'), currentModeDisplay: document.getElementById('current-mode'), accumulatedTimeDisplay: document.getElementById('accumulated-time'), endSessionBtn: document.getElementById('end-session-btn'), gaugeBar: document.getElementById('gauge-bar'), gaugePercent: document.getElementById('gauge-percent') };
            const sound = { notification: new Audio("{{ url_for('static', filename='sounds/decision1.mp3') }}") };

            let state = {
                timerId: null, mode: 'FOCUS', targetTime: 0,
                totalAccumulatedFocusTime: 0, currentPhaseStartTime: 0,
                gaugeLevel: 10, lastHiddenTime: 0, gaugeLevelOnHide: 100,
                wakeLock: null,
                isSessionActive: false,
                statusUpdateIntervalId: null,
                isFlowState: false,
                flowStateStartTime: null
            };

            // ★ sendUserStatusUpdate関数をinit()の呼び出しより前に移動
            async function sendUserStatusUpdate(status, gaugeLevel) {
                console.log('sendUserStatusUpdate: Sending status', status, 'gauge', gaugeLevel);
                try {
                    const response = await fetch("{{ url_for('main.update_user_status') }}", {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ status: status, gauge_level: gaugeLevel })
                    });
                    const data = await response.json();
                    console.log('sendUserStatusUpdate: Server response', data);
                    if (data.status !== 'success') {
                        console.error('Failed to update user status:', data.message);
                    }
                } catch (error) {
                    console.error('Error sending user status update:', error);
                }
            }

            const toggleWakeLock = async (enable) => {
                if (enable) {
                    try {
                        if ('wakeLock' in navigator) {
                            state.wakeLock = await navigator.wakeLock.request('screen');
                            console.log('Wake Lock is active.');
                        }
                    } catch (err) {
                        console.error(`${err.name}, ${err.message}`);
                    }
                } else {
                    if (state.wakeLock !== null) {
                        await state.wakeLock.release();
                        state.wakeLock = null;
                        console.log('Wake Lock was released.');
                    }
                }
            };

            async function endSession() {
                clearInterval(state.timerId);
                clearInterval(state.statusUpdateIntervalId);
                await toggleWakeLock(false);
                
                let finalFocusTime = state.totalAccumulatedFocusTime;
                if (state.mode === 'FOCUS') { finalFocusTime += (Date.now() - state.currentPhaseStartTime); }
                const totalMinutes = Math.floor(finalFocusTime / 1000 / 60);

                showCustomConfirm(`${totalMinutes}分のフォーカスを記録して終了しますか？`, async (confirmed) => {
                    if (confirmed) {
                        state.isSessionActive = false;
                        await sendUserStatusUpdate('オフライン', 0);
                        logSession(totalMinutes);
                    } else {
                        state.timerId = setInterval(tick, 1000);
                        state.statusUpdateIntervalId = setInterval(() => {
                            sendUserStatusUpdate(state.mode === 'FOCUS' ? 'フォーカス中' : '休憩中', Math.round(state.gaugeLevel));
                        }, 5000);
                        await toggleWakeLock(true);
                    }
                });
            }

            function logSession(duration) {
                fetch("{{ url_for('main.log_session') }}", {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ task_name: taskName, duration_minutes: duration })
                })
                .then(res => res.json())
                .then(data => {
                    if (data.status === 'success') { window.location.href = "{{ url_for('main.dashboard') }}"; }
                    else { showCustomAlert('エラー: ' + data.message); }
                })
                .catch(err => { console.error('Error:', err); showCustomAlert('サーバーとの通信中にエラーが発生しました。'); });
            }

            function handleVisibilityChange() {
                if (document.hidden) {
                    state.lastHiddenTime = Date.now();
                    state.gaugeLevelOnHide = state.gaugeLevel;
                } else {
                    const hiddenDuration = Date.now() - state.lastHiddenTime;
                    const penalty = (hiddenDuration / 1000) * GAUGE_PENALTY_RATE;
                    state.gaugeLevel = Math.max(0, state.gaugeLevelOnHide - penalty);
                }
            }

            function updateDisplay() {
                const now = Date.now();
                const timeLeft = Math.round((state.targetTime - now) / 1000);
                if (timeLeft >= 0) {
                    elements.timerDisplay.textContent = `${String(Math.floor(timeLeft / 60)).padStart(2, '0')}:${String(timeLeft % 60).padStart(2, '0')}`;
                }
                let currentFocusTime = state.totalAccumulatedFocusTime;
                if (state.mode === 'FOCUS') { currentFocusTime += (now - state.currentPhaseStartTime); }
                elements.accumulatedTimeDisplay.textContent = `合計フォーカス時間: ${Math.floor(currentFocusTime / 1000 / 60)}分`;
                elements.gaugeBar.style.width = `${state.gaugeLevel}%`;
                elements.gaugePercent.textContent = `${Math.round(state.gaugeLevel)}%`;
            }

            function startPhase(mode) {
                if (state.mode === 'FOCUS') { state.totalAccumulatedFocusTime += (state.targetTime - state.currentPhaseStartTime); }
                state.mode = mode;
                state.currentPhaseStartTime = Date.now();
                const duration = (mode === 'FOCUS') ? FOCUS_TIME_SECONDS : BREAK_TIME_SECONDS;
                state.targetTime = state.currentPhaseStartTime + duration * 1000;
                elements.currentModeDisplay.textContent = (mode === 'FOCUS') ? 'フォーカスモード' : '休憩モード';
                elements.currentModeDisplay.className = (mode === 'FOCUS') ? 'focus' : 'break';
                elements.container.className = 'focus-container ' + ((mode === 'FOCUS') ? 'focus-bg' : 'break-bg');
                sound.notification.play().catch(e => console.log("サウンドの再生に失敗"));
                sendUserStatusUpdate(state.mode === 'FOCUS' ? 'フォーカス中' : '休憩中', Math.round(state.gaugeLevel));
            }

            function tick() {
                if (Date.now() >= state.targetTime) { startPhase(state.mode === 'FOCUS' ? 'BREAK' : 'FOCUS'); }
                if (!document.hidden && state.mode === 'FOCUS' && state.gaugeLevel < 100) { state.gaugeLevel = Math.min(100, state.gaugeLevel + GAUGE_RECOVERY_RATE); }

                // Flow state detection
                if (state.mode === 'FOCUS' && !state.isFlowState) {
                    if (state.gaugeLevel >= FLOW_STATE_THRESHOLD) {
                        if (state.flowStateStartTime === null) {
                            state.flowStateStartTime = Date.now();
                        } else if (Date.now() - state.flowStateStartTime >= FLOW_STATE_DURATION) {
                            enterFlowState();
                        }
                    } else {
                        state.flowStateStartTime = null;
                    }
                }

                updateDisplay();
            }

            function enterFlowState() {
                if (state.isFlowState) return; // Already in flow state, do not re-notify

                state.isFlowState = true;
                elements.container.classList.add('flow-state-bg');
                elements.currentModeDisplay.textContent = 'フロー状態';
                sendUserStatusUpdate('フロー状態', Math.round(state.gaugeLevel));

                // Notify the server
                fetch("{{ url_for('main.flow_state_achieved') }}", { method: 'POST' });
            }

            async function init() {
                state.isSessionActive = true;
                await toggleWakeLock(true);
                state.currentPhaseStartTime = Date.now();
                state.targetTime = state.currentPhaseStartTime + FOCUS_TIME_SECONDS * 1000;
                elements.container.classList.add('focus-bg');
                elements.currentModeDisplay.classList.add('focus');
                document.addEventListener('visibilitychange', handleVisibilityChange);
                state.timerId = setInterval(tick, 1000);
                
                console.log('init: Calling sendUserStatusUpdate (initial)');
                await sendUserStatusUpdate('フォーカス中', Math.round(state.gaugeLevel));
                console.log('init: sendUserStatusUpdate (initial) returned');

                state.statusUpdateIntervalId = setInterval(() => {
                    console.log('setInterval: Calling sendUserStatusUpdate');
                    if (!state.isFlowState) { // Only send status update if not in flow state
                        sendUserStatusUpdate(state.mode === 'FOCUS' ? 'フォーカス中' : '休憩中', Math.round(state.gaugeLevel));
                    }
                }, 5000);

                tick();
                elements.endSessionBtn.addEventListener('click', endSession);

                const debugFlowBtn = document.getElementById('debug-flow-btn');
                if (debugFlowBtn) {
                    debugFlowBtn.addEventListener('click', () => {
                        state.gaugeLevel = 100; // Set gauge to 100 for debug
                        enterFlowState();
                    });
                }

                // --- New Debug Code ---
                const debugGauge0Btn = document.getElementById('debug-gauge-0');
                const debugGauge50Btn = document.getElementById('debug-gauge-50');
                const debugGauge100Btn = document.getElementById('debug-gauge-100');

                if (debugGauge0Btn) {
                    debugGauge0Btn.addEventListener('click', () => {
                        state.gaugeLevel = 0;
                        updateDisplay();
                    });
                }
                if (debugGauge50Btn) {
                    debugGauge50Btn.addEventListener('click', () => {
                        state.gaugeLevel = 50;
                        updateDisplay();
                    });
                }
                if (debugGauge100Btn) {
                    debugGauge100Btn.addEventListener('click', () => {
                        state.gaugeLevel = 100;
                        updateDisplay();
                    });
                }
            }

            init();
        });

        window.addEventListener('unload', () => {
            if (state.isSessionActive) {
                const data = JSON.stringify({ status: 'オフライン', gauge_level: 0 });
                navigator.sendBeacon("{{ url_for('main.update_user_status') }}", data);
            }
        });
    </script>
</body>
</html>
